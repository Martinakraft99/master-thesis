\section{Implementation overview}

The control system outlined in \ref{chap:design} was implemented and simulated in \textit{Matlab R2023b}\cite{MATLAB}. The implementation consists of both Matlab scripts and a Simulink model. The scripts define initial values and fetch all the data the Simulink model requires to run. The interaction is highlighted in\ref{fig:system_arch_flowchart}.

To create the simulation the following models had to be implemented in Simulink:
\begin{itemize}
    \item \textit{Load Forecaster}
    \item \textit{Production Forecaster}
    \item \textit{Battery Module}
    \item \textit{Optimizer}
    \item \textit{Controller}
    \item \textit{Controller Current Control System}
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Figures/08Implementation/system_arch_flowchart.png}
    \caption[Control System architecture flowchart]{Flowchart of the control system architecture.}
    \label{fig:system_arch_flowchart}
\end{figure}


The interaction between the modules is shown in \ref{fig:control_system_block_chart}.

In the implementation, consumption data was collected with a \textbf{15-minute} resolution, however, as production and weather data is in \textbf{1-hour} resolution, and to increase simulation speed, the optimizer is set to run only at every hour. 

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Figures/08Implementation/control_system_overview.png}
    \caption[Proposed control system block chart]{Chart showing the main components and signals of the implemented solution in simulation. ($p$ - production at ts, $r$ - demand at ts, $\hat{R}$ - demand forecast for the whole prediction horizon. $\hat{P}$ - production forecast for the whole prediction horizon. $p_b$ - power to/from battery, $b$ - battery capacity at ts, Priority NFL - The internal priority of the non-flexible loads, Alloc FL - The power allocated to the flexible loads, Alloc pb - allocated power to/from the battery.)}
    \label{fig:control_system_block_chart}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Figures/08Implementation/control_as_is_overview.png}
    \caption[Current control system block chart]{Chart showing the main components and signals of the current control system in simulation. $p$ - production at ts, $r$ - demand at ts, $b$ - battery capacity at ts, $pb$ - power to/from the battery, $chargeON$ - control signal to shut down battery charging. The $chargeON$ mechanism is highlighted in the battery control system shown in figure \ref{fig:current_battery_control_FSM}. The loop with ALLOC FL* and ALLOC FL through the integrator is to prevent the allocation to the flexible loads from exceeding daily demand.}
    \label{fig:control_as_is_overview}
\end{figure}


\section{Battery Module}
The battery itself is simply modelled by an integrator integrating a saturated signal. The signal is saturated so that it cannot exceed the maximum charge/discharge rate of the battery. The integrator is also saturated to not exceed the max or minimum capacity of the battery. In addition, as the controller has a 15-min resolution, a block is added to convert this to hourly resolution because the battery capacity is defined in watts per hour (W/h).

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Figures/08Implementation/battery_model.png}
    \caption[Battery module block diagram]{Block diagram for the battery module. $p_b$ - power to/from the battery during the 15 min interval, $pb_{h1}'$ - power to/from the battery converted to hourly resolution, $pb_{h1}$ - is the same as $pb_{h1}'$ only saturated by the max charge/discharge rate.}
    \label{fig:battery_block}
\end{figure}

\section{Load Forecaster}

The load forecaster consists of the forecast block implementing the load forecasting algorithm outlined in section \ref{seq:load_forecasting}. This is wrapped in a feedback loop using a PID controller. A new forecast is made using the forecasting algorithm once every hour, the consumption is however measured every 15 minutes. In between the forecasts, the PID controller reduces the error between demand and the forecast until a new forecast is made. The algorithm shown in \ref{alg:load_forecast} shows the internal of the forecast block. The forecaster yields a forecast over the whole prediction horizon. The first element of this forecast is extracted out and used in the feed-back loop.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Figures/08Implementation/load_forecast.png}
    \caption[Load forecaster block diagram]{Block diagram for the load forecaster. $r_t$ - demand at time t, $\hat{r}_t$ - forecasted demand at time t, $e_t$ - estimation error at time t, $e_{t-1}$ - estimation error at time t-1, $u_t$ - forecast input at time t, $\hat{R}_t$ - forecasted demand over the whole prediction horizon at time t.}
    \label{fig:load_forecaster_block}
\end{figure}

\begin{algorithm}
\caption{Load forecaster algorithm (Pseudocode)}\label{alg:load_forecast}
\begin{algorithmic}

\If{simulationTime==wholeHour}  \Comment{Only forecast every hour}
    \State$historicData \gets [historicData,r_{t-1}]$
    \State$forecastData \gets arimaForecast(historicData,coefficients,predictionHorizon)$
\EndIf\\
    \State$\hat{R}_t = forecastData + u_t $
    \State$\hat{r}_t = \hat{R}_t(:,1)$  \Comment{Extract first estimate}
\end{algorithmic}
\end{algorithm}

\section{Production Forecaster}
The production forecaster has an identical internal layout to the forecast block. Also here the forecast algorithm from section \ref{seq:prod_forecasting} is wrapped in a feedback loop with a PID control to minimize error until the next forecast is made. Algorithm \ref{alg:prod_forecast} shows the internal of the forecast block of the production forecaster module. The forecaster yields a forecast over the whole prediction horizon. The first element of this forecast is extracted out and used in the feed-back loop.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{Figures/08Implementation/prod_forecast.png}
    \caption[Production forecaster block diagram]{Block diagram for the production forecaster. $p_t$ - demand at time t, $\hat{p}_t$ - forecasted demand at time t, $e_t$ - estimation error at time t, $e_{t-1}$ - estimation error at time t-1, $u_t$ - forecast input at time t, $\hat{P}_t$ - forecasted production over the whole prediction horizon at time t.}
    \label{fig:prod_forecaster_block}
\end{figure}

\begin{algorithm}
\caption{Production forecaster algorithm (Pseudocode)}\label{alg:prod_forecast}
\begin{algorithmic}
    
\If{simulationTime==wholeHour}  \Comment{Only forecast every hour}
    \State$historicData \gets [historicData,p_{t-1}]$
    \State$forecastData \gets modelForecast(historicData,coefficients,predictionHorizon)$
\EndIf\\
    \State$\hat{P}_t = forecastData + u_t $
    \State$\hat{r}_t = \hat{P}_t(:,1)$  \Comment{Extract first estimate}
\end{algorithmic}
\end{algorithm}



\section{Optimizer}
The optimizer implements the design from \ref{sec:optimization}. The optimizer algorithm including the non-linear optimization and post-processing is outlined in algorithm \ref{alg:optimizer}. The non-linear optimization is performed using Matlabs \textit{fmincon} with the 'interior-point' algorithm. the output from the optimizer is the priority given to non-flexible loads, Priority NFL, the allocation to flexible loads, Alloc FL, and the allocation to/from the battery, Alloc pb

\begin{algorithm}
\caption{Optimizer algorithm (Pseudocode)}\label{alg:optimizer}
\begin{algorithmic}
    \State$\hat{R},\hat{P},b  \gets \hat{R}_t,\hat{P}_t,b_t$                        \Comment{Get signals}
    \State$C, K \gets C, K $                                                        \Comment{Get constants}\\
    
\If{simulationTime==wholeHour}                                                      \Comment{Only optimize every hour}
    \State$constraints \gets constraints(\hat{P},b)$                                \Comment{Set constraint function}
    \State$objectiveFunction \gets objectiveFunction(\hat{R},C,b,K)$                \Comment{Set objective}
    \State$L,pb' = optimize(objectiveFunction, constraints)$
    \State$allocNFL,allocFL \gets splitFlexAndNonFlexLoads(L)$
    \\
    \State$priorityNFL \gets sort(allocNFL\div\hat{R}(1))$                          \Comment{Find priority NFL}\\
    

    \For{$\text{flexLoad in }(allocFL)$}                                            \Comment{Find allocation FL}
        \If{$flexLoad \geq flexLoadMinW$}
            \State$allocFL(flexLoad) = flexLoad$
        \Else
            \State$allocFL(flexLoad) = 0$
        \EndIf
    \EndFor\\
    
    \State$\text{Alloc pb} \gets pb'(1)$                                                         \Comment{Extract first battery allocation}\\

    \State  $Out \gets priorityNFL,  allocFL,  \text{Alloc pb}$
\EndIf
\end{algorithmic}
\end{algorithm}

\section{Controller current control system}
The controller for the current control system includes both the controller itself and the integrator in figure \ref{fig:control_as_is_overview}. The integrator is included to stop the flexible loads from exceeding their demand. The current control system algorithm is shown in algorithm \ref{alg:current_control}.

\begin{algorithm}
\caption{Current Control Algorithm (Pseudocode)}\label{alg:current_control}
    \begin{algorithmic}
    
        \State $p_b' \gets \min([\text{pb\_max}, (b - \text{b\_min})])$
        \State $\text{p\_load} \gets p + p_b'$
        \State $\text{p\_load} \gets \min([\text{inv\_max}, \text{p\_load}])$       \Comment{Calculate available power}\\
        
    
        \For{demandLoad in r}                                           \Comment{Add load if available power} 
            \If{$(\text{p\_load} - \text{demandLoad}) > 0$}
                \State loadON $\gets$ demandLoad
                \State $\text{p\_load} \gets (\text{p\_load} - \text{demandLoad}) $       \Comment{Reduce available power}
            \EndIf
        \EndFor\\
    
        \For{f in flexibleLoads}
            \If{$\text{simulationTime} \in f\_run\_interval$}                       \Comment{Check if load set to run} 
                \If{$(\text{p\_load} - \text{f}) > 0$}
                    \State $\text{loadON} \gets f $                                   \Comment{Add load if available power} 
                    \State $\text{p\_load} \gets (\text{p\_load} - \text{f}) $       \Comment{Reduce available power}
                \EndIf
            \EndIf
        \EndFor\\

        \State $p_b \gets (\text{p\_load - loadON})$\\
        
        \If{$b \geq \text{b\_max} \times 0.9$ \textbf{and} $\text{simulationTime} < 15$}
            \State $\text{chargeON} \gets 0$                               \Comment{Stop charge ref. \ref{fig:current_battery_control_FSM}} 
        \EndIf\\
        \State{Out $\gets \text{loadON },p_b, \text{ chargeON}$}
    \end{algorithmic}
\end{algorithm}


\section{Controller}
In the simulation, the controller implements the plan from the optimizer continuously until a new plan is received. The algorithm is shown in algorithm \ref{alg:controller}. In addition to the steps outlined in section \ref{sec:controller}, an additional step is added for the simulation to reduce the draining of the battery to be no larger than the power consumed by the loads. 

Algorithm \ref{alg:controller} shows the controller algorithm. Its inputs are the instantaneous demand, production, battery SOC, the priority of non-flexible loads, the allocation to flexible loads and allocation to/from the battery. In the simulation, its outputs are the allocated power to the loads and charged/discharged from the battery. 

\begin{algorithm}
\caption{Controller algorithm (Pseudocode)}\label{alg:controller}
\begin{algorithmic}
    \State$p_b'  \gets \text{min(Alloc pb, b)}$
    \State$p_{available}  \gets \text{min(p - $p_b'$, $inv_{max}$)}$               \Comment{Calculate available power}\\
    
    \For{demand in priorityNFL}
        \If{$totalLoad + demand \leq p_{available}$}
            \State$totalLoad  = totalLoad + demand_{load}$
            \State$loadON  \gets \text{priorityNFL(demand)}$                    \Comment{Allow load to run}
        \EndIf
    \EndFor\\

    \For{demand in AllocFL}
        \If{$totalLoad + demand \leq p_{available}$}
            \State$totalLoad  = totalLoad + demand_{load}$
            \State$loadON  \gets \text{AllocFL(demand)}$                    \Comment{Allow load to run at allocated power}
        \EndIf
    \EndFor\\
    
\If{$p_{b}<0$}
    \State$p_{b} \gets \text{max($p_b'$, -totalLoad)}$
\Else
    \State$p_{b} \gets p_b' $
\EndIf\\
\State{Out $\gets p_b$,\text{ loadON}}
\end{algorithmic}
%\caption{The Controller algorithm. From an input}
\end{algorithm}